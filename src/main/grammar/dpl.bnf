{
    parserClass="pl.thedeem.intellij.dpl.DPLParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="DPL"
    psiImplClassSuffix="Impl"
    psiPackage="pl.thedeem.intellij.dpl.psi"
    psiImplPackage="pl.thedeem.intellij.dpl.impl"

    elementTypeHolderClass="pl.thedeem.intellij.dpl.psi.DPLTypes"
    elementTypeClass="pl.thedeem.intellij.dpl.psi.DPLElementType"
    tokenTypeClass="pl.thedeem.intellij.dpl.psi.DPLTokenType"

    psiImplUtilClass="pl.thedeem.intellij.dpl.psi.DPLPsiImplUtil"

    consumeTokenMethod(".*")="consumeTokenFast"

    tokens=[
        IDENTIFIER = 'regexp:[A-Za-z_][A-Za-z0-9_]*'
        LONG = 'regexp:-?[0-9]+'
        DOUBLE = 'regexp:-?[0-9]+\.[0-9]+'
        SI_NUMBER = 'regexp:-?[0-9]+(\.[0-9]+)?e-?[0-9]+'
        HEX_NUMBER = 'regexp:-?0[xX][0-9A-Fa-f]+'
        SET = '='
        L_BRACE = '{'
        R_BRACE = '}'
        L_PAREN = '('
        R_PAREN = ')'
        L_BRACKET = '['
        R_BRACKET = ']'
        L_ARROW = '<'
        R_ARROW = '>'
        COMMA = ','
        COLON = ':'
        NULL_TYPE = 'null'
        TRUE = 'true'
        FALSE = 'false'
        OPTIONAL = '?'
        SUBTRACT = '-'
        ADD = '+'
        MULTIPLY = '*'
        PLA = '>>'
        PLB = '<<'
        OR = '|'
        SEMICOLON = ';'
        NEGATION='!'
        EOL_COMMENT = 'regexp://.*'
        ML_COMMENT_START = '/*'
        ML_COMMENT_FINISH = '*/'
    ]
}

root ::= (comment?) dpl
comment ::= EOL_COMMENT | ML_COMMENT
dpl ::= macro_definition_expression* expressions_sequence? expression_end?
expressions_sequence ::= expression_definition (COMMA? expression_definition)* {
    implements="pl.thedeem.intellij.dpl.psi.elements.SequenceElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.SequenceElementImpl"
}
expression_definition ::= expression {
    implements="pl.thedeem.intellij.dpl.psi.elements.ExpressionElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.ExpressionElementImpl"
}

expression ::=
    modifier_expression |
    definition_expression {
    implements="pl.thedeem.intellij.dpl.psi.elements.BaseExpression"
}

private modifier_expression ::=
    meta_expression |
    nullable_expression |
    export_name_expression |
    lookaround_expression |
    quantifier_expression |
    matchers_expression |
    configuration_expression

definition_expression ::=
    literal_expression |
    variable_usage_expression |
    parameter_expression |
    command_expression |
    group_expression |
    character_group_expression {
    extends=expression
    implements="pl.thedeem.intellij.dpl.psi.elements.BaseExpression"
}

macro_definition_expression ::= variable SET expressions_sequence expression_end {
    pin=2
    extends=expression
    implements="pl.thedeem.intellij.dpl.psi.elements.MacroExpressionElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.MacroExpressionElementImpl"
}
export_name_expression ::= expression COLON field_name {
    extends=expression
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.ExportNameExpressionElementImpl"
    implements="pl.thedeem.intellij.dpl.psi.elements.ExportNameExpressionElement"
}
lookaround_expression ::= lookaround expression {
    pin=1
    extends=expression
    rightAssociative=true
    implements="pl.thedeem.intellij.dpl.psi.elements.ModifierExpression"
}
nullable_expression ::= expression nullable {
    extends=expression
    implements="pl.thedeem.intellij.dpl.psi.elements.ModifierExpression"
}
nullable ::= OPTIONAL
literal_expression ::= string {
    extends=definition_expression
    pin=1
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.LiteralExpressionElementImpl"
    implements="pl.thedeem.intellij.dpl.psi.elements.LiteralExpressionElement"
}
variable_usage_expression ::= variable {
    extends=definition_expression
    pin=1
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.VariableUsageExpressionElementImpl"
    implements="pl.thedeem.intellij.dpl.psi.elements.VariableUsageExpressionElement"
}

meta_expression ::= expression L_ARROW meta_expression_content? R_ARROW {
    extends=expression
    pin=2
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.MetaExpressionElementImpl"
    implements="pl.thedeem.intellij.dpl.psi.elements.MetaExpressionElement"
}

meta_expression_content ::= simple_expression | expression {
  recoverWhile=recover_meta_expression_content
}

// Groups
group_expression ::= L_PAREN group_expression_content? R_PAREN {
    pin=1
    extends=definition_expression
    implements="pl.thedeem.intellij.dpl.psi.elements.GroupElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.GroupElementImpl"
}
private group_expression_content ::= alternatives_expression | expressions_sequence {
    recoverWhile=recover_alternative_content
}
alternatives_expression ::= alternative_group_content {
    implements="pl.thedeem.intellij.dpl.psi.elements.AlternativesGroupElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.AlternativesGroupElementImpl"
}
private alternative_group_content ::= expression_definition OR expression_definition (OR expression_definition)* {
    pin=2
    recoverWhile=recover_alternative_content
}

// Character groups
character_group_expression ::= L_BRACKET character_group_content R_BRACKET {
    pin=1
    extends=definition_expression
    implements="pl.thedeem.intellij.dpl.psi.elements.CharacterGroupExpressionElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.CharacterGroupExpressionElementImpl"
}
character_group_content ::= CHARACTER_CLASS {
    implements="pl.thedeem.intellij.dpl.psi.elements.CharacterGroupContentElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.CharacterGroupContentElementImpl"
}

// Commands
command_expression ::= command_keyword {
    extends=definition_expression
    pin=1
    implements="pl.thedeem.intellij.dpl.psi.elements.CommandElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.CommandElementImpl"
}
command_keyword ::= IDENTIFIER {
    implements="pl.thedeem.intellij.dpl.psi.elements.CommandKeywordElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.CommandKeywordElementImpl"
}

// Matchers
matchers_expression ::= expression L_BRACE command_matchers_content? R_BRACE {
    extends=expression
    implements="pl.thedeem.intellij.dpl.psi.elements.CommandMatchersElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.CommandMatchersElementImpl"
}
command_matchers_content ::= parameters_matchers_list | members_list_matchers | expression_matchers_list
expression_matchers_list ::= matcher_item+ {
    extends=command_matchers_content
}
parameters_matchers_list ::= matcher (COMMA matcher)* {
    extends=command_matchers_content
}
members_list_matchers ::= matcher_item COMMA matcher_item (COMMA matcher_item)* {
    pin=2
    extends=command_matchers_content
}
private matcher_item ::= expression_definition
matcher ::= matcher_name SET simple_expression {
    pin=2
    implements="pl.thedeem.intellij.dpl.psi.elements.MatcherElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.MatcherElementImpl"
}
matcher_name ::= string {
    implements="pl.thedeem.intellij.dpl.psi.elements.MatcherNameElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.MatcherNameElementImpl"
}

configuration_expression ::= expression L_PAREN configuration_content R_PAREN {
    extends=expression
    implements="pl.thedeem.intellij.dpl.psi.elements.ConfigurationElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.ConfigurationElementImpl"
}
configuration_content ::= parameter_expression (COMMA parameter_expression)* {
    recoverWhile=recover_configuration_content
    implements="pl.thedeem.intellij.dpl.psi.elements.ConfigurationContentElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.ConfigurationContentElementImpl"
}
parameter_expression ::= named_parameter | unnamed_parameter {
    extends=expression
    implements="pl.thedeem.intellij.dpl.psi.elements.ParameterElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.NamedParameterElementImpl"
}
private named_parameter ::= parameter_name SET parameter_value {
    pin=2
    extends=parameter_expression
}
private unnamed_parameter ::= parameter_value {
    extends=parameter_expression
}

parameter_value ::= simple_expression
parameter_name ::= IDENTIFIER {
    implements="pl.thedeem.intellij.dpl.psi.elements.ParameterNameElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.ParameterNameElementImpl"
}

// Quantifiers
quantifier_expression ::= expression quantifier_content {
    extends=expression
    implements="pl.thedeem.intellij.dpl.psi.elements.QuantifierElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.QuantifierElementImpl"
}
quantifier_content ::= limited_quantifier | simple_quantifier {
    implements="pl.thedeem.intellij.dpl.psi.elements.QuantifierContentElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.QuantifierContentElementImpl"
}

simple_quantifier ::= ADD | MULTIPLY {
    extends=quantifier_content
    pin=1
}
limited_quantifier ::= L_BRACE limited_quantifier_ranges? R_BRACE {
    extends=quantifier_content
}
limited_quantifier_ranges ::= min_max_quantifier | min_quantifier | max_quantifier | exact_quantifier
min_max_quantifier ::= quantifier_limit COMMA quantifier_limit {
    extends=limited_quantifier_ranges
}
min_quantifier ::= quantifier_limit COMMA {
    extends=limited_quantifier_ranges
}
max_quantifier ::= COMMA quantifier_limit {
    extends=limited_quantifier_ranges
}
exact_quantifier ::= quantifier_limit {
    extends=limited_quantifier_ranges
}
quantifier_limit ::= LONG {
    implements="pl.thedeem.intellij.dpl.psi.elements.QuantifierLimitElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.QuantifierLimitElementImpl"
}

// Other definitions
simple_expression ::=
    string |
    boolean |
    number |
    null

field_name ::= DOTTED_IDENTIFIER | IDENTIFIER | string {
    implements="pl.thedeem.intellij.dpl.psi.elements.FieldNameElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.FieldNameElementImpl"
}

string ::= double_quoted_string | single_quoted_string {
    extends=simple_expression
}
double_quoted_string ::= DOUBLE_QUOTE string_content_element? DOUBLE_QUOTE {
    pin=1
    extends=string
    implements="pl.thedeem.intellij.dpl.psi.elements.StringElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.StringElementImpl"
}
single_quoted_string ::= SINGLE_QUOTE string_content_element? SINGLE_QUOTE {
    pin=1
    extends=string
    implements="pl.thedeem.intellij.dpl.psi.elements.StringElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.StringElementImpl"
}
string_content_element ::= STRING_CONTENT {
    implements="pl.thedeem.intellij.dpl.psi.elements.StringElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.StringElementImpl"
}

boolean ::= TRUE | FALSE {
   extends=simple_expression
   implements="pl.thedeem.intellij.dpl.psi.elements.BooleanElement"
   mixin="pl.thedeem.intellij.dpl.psi.elements.impl.BooleanElementImpl"
}
null ::= NULL_TYPE {
   extends=simple_expression
   implements="pl.thedeem.intellij.dpl.psi.elements.NullElement"
   mixin="pl.thedeem.intellij.dpl.psi.elements.impl.NullElementImpl"
}
number ::= LONG | DOUBLE | SI_NUMBER | HEX_NUMBER {
   extends=simple_expression
   implements="pl.thedeem.intellij.dpl.psi.elements.NumberElement"
   mixin="pl.thedeem.intellij.dpl.psi.elements.impl.NumberElementImpl"
}
variable ::= VARIABLE_NAME {
    implements="pl.thedeem.intellij.dpl.psi.elements.VariableElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.VariableElementImpl"
}

expression_end ::= SEMICOLON
lookaround ::= NEGATION? (PLA | PLB) {
    pin=2
    implements="pl.thedeem.intellij.dpl.psi.elements.LookaroundElement"
    mixin="pl.thedeem.intellij.dpl.psi.elements.impl.LookaroundElementImpl"
}

private recover_configuration_content ::= !(IDENTIFIER|OR|R_PAREN|L_PAREN|L_BRACE|L_BRACKET)
private recover_alternative_content ::= !(OR|R_PAREN)
private recover_meta_expression_content ::= !(R_ARROW)
